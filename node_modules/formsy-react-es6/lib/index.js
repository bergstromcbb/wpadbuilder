'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp2, _initialiseProps;

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PropTypes = require('prop-types');
var React = global.React || require('react');
var Formsy = {};
var validationRules = require('./validationRules.js');
var formDataToObject = require('form-data-to-object');
var utils = require('./utils.js');
var Wrapper = require('./Wrapper.js');
var options = {};
var emptyArray = [];

Formsy.Wrapper = Wrapper;
Formsy.propTypes = {
    setValidations: PropTypes.func,
    setValue: PropTypes.func,
    resetValue: PropTypes.func,
    getValue: PropTypes.func,
    hasValue: PropTypes.func,
    getErrorMessage: PropTypes.func,
    getErrorMessages: PropTypes.func,
    isFormDisabled: PropTypes.func,
    isValid: PropTypes.func,
    isPristine: PropTypes.func,
    isFormSubmitted: PropTypes.func,
    isRequired: PropTypes.func,
    showRequired: PropTypes.func,
    showError: PropTypes.func,
    isValidValue: PropTypes.func
};

Formsy.defaults = function (passedOptions) {
    options = passedOptions;
};

Formsy.addValidationRule = function (name, func) {
    validationRules[name] = func;
};

Formsy.Form = (_temp2 = _class = function (_React$Component) {
    _inherits(FormsyForm, _React$Component);

    function FormsyForm() {
        var _ref;

        var _temp, _this, _ret;

        _classCallCheck(this, FormsyForm);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = FormsyForm.__proto__ || Object.getPrototypeOf(FormsyForm)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(FormsyForm, [{
        key: 'getChildContext',
        value: function getChildContext() {
            var _this2 = this;

            return {
                formsy: {
                    attachToForm: this.attachToForm,
                    detachFromForm: this.detachFromForm,
                    validate: this.validate,
                    isFormDisabled: this.isFormDisabled,
                    isValidValue: function isValidValue(component, value) {
                        return _this2.runValidation(component, value).isValid;
                    }
                }
            };
        }

        // Add a map to store the inputs of the form, a model to store
        // the values of the form and register child inputs

    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            this.inputs = [];
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.validateForm();
        }
    }, {
        key: 'componentWillUpdate',
        value: function componentWillUpdate() {
            // Keep a reference to input names before form updates,
            // to check if inputs has changed after render
            this.prevInputNames = this.inputs.map(function (component) {
                return component.props.name;
            });
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            if (this.props.validationErrors && _typeof(this.props.validationErrors) === 'object' && Object.keys(this.props.validationErrors).length > 0) {
                this.setInputValidationErrors(this.props.validationErrors);
            }

            var newInputNames = this.inputs.map(function (component) {
                return component.props.name;
            });
            if (utils.arraysDiffer(this.prevInputNames, newInputNames)) {
                this.validateForm();
            }
        }

        // Allow resetting to specified data


        // Update model, submit to url prop and send the model


        // Reset each key in the model to the original / initial / specified value


        // Checks if the values have changed from their initial value


        // Go through errors from server and grab the components
        // stored in the inputs map. Change their state to invalid
        // and set the serverError message


        // Use the binded values and the actual input value to
        // validate the input and set its state. Then check the
        // state of the form itself


        // Checks validation on current value or a passed value


        // Validate the form by going through all child input components
        // and check their state


        // Method put on each input component to register
        // itself to the form


        // Method put on each input component to unregister
        // itself from the form

    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                mapping = _props.mapping,
                validationErrors = _props.validationErrors,
                onSubmit = _props.onSubmit,
                onValid = _props.onValid,
                onValidSubmit = _props.onValidSubmit,
                onInvalid = _props.onInvalid,
                onInvalidSubmit = _props.onInvalidSubmit,
                onChange = _props.onChange,
                reset = _props.reset,
                preventExternalInvalidation = _props.preventExternalInvalidation,
                onSuccess = _props.onSuccess,
                onError = _props.onError,
                nonFormsyProps = _objectWithoutProperties(_props, ['mapping', 'validationErrors', 'onSubmit', 'onValid', 'onValidSubmit', 'onInvalid', 'onInvalidSubmit', 'onChange', 'reset', 'preventExternalInvalidation', 'onSuccess', 'onError']);

            return React.createElement(
                'form',
                _extends({}, nonFormsyProps, { onSubmit: this.submit }),
                this.props.children
            );
        }
    }]);

    return FormsyForm;
}(React.Component), _class.displayName = 'Formsy.Form', _class.defaultProps = {
    onSuccess: function onSuccess() {},
    onError: function onError() {},
    onSubmit: function onSubmit() {},
    onValidSubmit: function onValidSubmit() {},
    onInvalidSubmit: function onInvalidSubmit() {},
    onValid: function onValid() {},
    onInvalid: function onInvalid() {},
    onChange: function onChange() {},
    validationErrors: null,
    preventExternalInvalidation: false
}, _class.childContextTypes = {
    formsy: PropTypes.object
}, _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.state = {
        isValid: true,
        isSubmitting: false,
        canChange: false
    };

    this.reset = function (data) {
        _this3.setFormPristine(true);
        _this3.resetModel(data);
    };

    this.submit = function (event) {
        event && event.preventDefault();

        // Trigger form as not pristine.
        // If any inputs have not been touched yet this will make them dirty
        // so validation becomes visible (if based on isPristine)
        _this3.setFormPristine(false);
        var model = _this3.getModel();
        _this3.props.onSubmit(model, _this3.resetModel, _this3.updateInputsWithError);
        _this3.state.isValid ? _this3.props.onValidSubmit(model, _this3.resetModel, _this3.updateInputsWithError) : _this3.props.onInvalidSubmit(model, _this3.resetModel, _this3.updateInputsWithError);
    };

    this.mapModel = function (model) {
        if (_this3.props.mapping) {
            return _this3.props.mapping(model);
        } else {
            return formDataToObject.toObj(Object.keys(model).reduce(function (mappedModel, key) {

                var keyArray = key.split('.');
                var base = mappedModel;
                while (keyArray.length) {
                    var currentKey = keyArray.shift();
                    base = base[currentKey] = keyArray.length ? base[currentKey] || {} : model[key];
                }

                return mappedModel;
            }, {}));
        }
    };

    this.getModel = function () {
        var currentValues = _this3.getCurrentValues();
        return _this3.mapModel(currentValues);
    };

    this.resetModel = function (data) {
        _this3.inputs.forEach(function (component) {
            var name = component.props.name;
            if (data && data.hasOwnProperty(name)) {
                component.setValue(data[name]);
            } else {
                component.resetValue();
            }
        });
        _this3.validateForm();
    };

    this.setInputValidationErrors = function (errors) {
        _this3.inputs.forEach(function (component) {
            var name = component.props.name;
            var args = [{
                _isValid: !(name in errors),
                _validationError: typeof errors[name] === 'string' ? [errors[name]] : errors[name]
            }];
            component.setState.apply(component, args);
        });
    };

    this.isChanged = function () {
        return !utils.isSame(_this3.getPristineValues(), _this3.getCurrentValues());
    };

    this.getPristineValues = function () {
        return _this3.inputs.reduce(function (data, component) {
            var name = component.props.name;
            data[name] = component.props.value;
            return data;
        }, {});
    };

    this.updateInputsWithError = function (errors) {
        Object.keys(errors).forEach(function (name, index) {
            var component = utils.find(_this3.inputs, function (component) {
                return component.props.name === name;
            });
            if (!component) {
                throw new Error('You are trying to update an input that does not exist. ' + 'Verify errors object with input names. ' + JSON.stringify(errors));
            }
            var args = [{
                _isValid: _this3.props.preventExternalInvalidation || false,
                _externalError: typeof errors[name] === 'string' ? [errors[name]] : errors[name]
            }];
            component.setState.apply(component, args);
        });
    };

    this.isFormDisabled = function () {
        return _this3.props.disabled;
    };

    this.getCurrentValues = function () {
        return _this3.inputs.reduce(function (data, component) {
            var name = component.props.name;
            data[name] = component.state._value;
            return data;
        }, {});
    };

    this.setFormPristine = function (isPristine) {
        _this3.setState({
            _formSubmitted: !isPristine
        });

        // Iterate through each component and set it as pristine
        // or "dirty".
        _this3.inputs.forEach(function (component, index) {
            component.setState({
                _formSubmitted: !isPristine,
                _isPristine: isPristine
            });
        });
    };

    this.validate = function (component) {
        // Trigger onChange
        if (_this3.state.canChange) {
            _this3.props.onChange(_this3.getCurrentValues(), _this3.isChanged());
        }

        var validation = _this3.runValidation(component);
        // Run through the validations, split them up and call
        // the validator IF there is a value or it is required
        component.setState({
            _isValid: validation.isValid,
            _isRequired: validation.isRequired,
            _validationError: validation.error,
            _externalError: null
        }, _this3.validateForm);
    };

    this.runValidation = function (component, value) {
        var currentValues = _this3.getCurrentValues();
        var validationErrors = component.props.validationErrors;
        var validationError = component.props.validationError;
        value = value ? value : component.state._value;

        var validationResults = _this3.runRules(value, currentValues, component._validations);
        var requiredResults = _this3.runRules(value, currentValues, component._requiredValidations);

        // the component defines an explicit validate function
        if (typeof component.validate === "function") {
            validationResults.failed = component.validate() ? [] : ['failed'];
        }

        var isRequired = Object.keys(component._requiredValidations).length ? !!requiredResults.success.length : false;
        var isValid = !validationResults.failed.length && !(_this3.props.validationErrors && _this3.props.validationErrors[component.props.name]);

        return {
            isRequired: isRequired,
            isValid: isRequired ? false : isValid,
            error: function () {

                if (isValid && !isRequired) {
                    return emptyArray;
                }

                if (validationResults.errors.length) {
                    return validationResults.errors;
                }

                if (this.props.validationErrors && this.props.validationErrors[component.props.name]) {
                    return typeof this.props.validationErrors[component.props.name] === 'string' ? [this.props.validationErrors[component.props.name]] : this.props.validationErrors[component.props.name];
                }

                if (isRequired) {
                    var error = validationErrors[requiredResults.success[0]];
                    return error ? [error] : null;
                }

                if (validationResults.failed.length) {
                    return validationResults.failed.map(function (failed) {
                        return validationErrors[failed] ? validationErrors[failed] : validationError;
                    }).filter(function (x, pos, arr) {
                        // Remove duplicates
                        return arr.indexOf(x) === pos;
                    });
                }
            }.call(_this3)
        };
    };

    this.runRules = function (value, currentValues, validations) {
        var results = {
            errors: [],
            failed: [],
            success: []
        };

        if (Object.keys(validations).length) {
            Object.keys(validations).forEach(function (validationMethod) {

                if (validationRules[validationMethod] && typeof validations[validationMethod] === 'function') {
                    throw new Error('Formsy does not allow you to override default validations: ' + validationMethod);
                }

                if (!validationRules[validationMethod] && typeof validations[validationMethod] !== 'function') {
                    throw new Error('Formsy does not have the validation rule: ' + validationMethod);
                }

                if (typeof validations[validationMethod] === 'function') {
                    var validation = validations[validationMethod](currentValues, value);
                    if (typeof validation === 'string') {
                        results.errors.push(validation);
                        results.failed.push(validationMethod);
                    } else if (!validation) {
                        results.failed.push(validationMethod);
                    }
                    return;
                } else if (typeof validations[validationMethod] !== 'function') {
                    var validation = validationRules[validationMethod](currentValues, value, validations[validationMethod]);
                    if (typeof validation === 'string') {
                        results.errors.push(validation);
                        results.failed.push(validationMethod);
                    } else if (!validation) {
                        results.failed.push(validationMethod);
                    } else {
                        results.success.push(validationMethod);
                    }
                    return;
                }

                return results.success.push(validationMethod);
            });
        }

        return results;
    };

    this.validateForm = function () {
        // We need a callback as we are validating all inputs again. This will
        // run when the last component has set its state
        var onValidationComplete = function () {
            var allIsValid = this.inputs.every(function (component) {
                return component.state._isValid;
            });

            this.setState({
                isValid: allIsValid
            });

            if (allIsValid) {
                this.props.onValid();
            } else {
                this.props.onInvalid();
            }

            // Tell the form that it can start to trigger change events
            this.setState({
                canChange: true
            });
        }.bind(_this3);

        // Run validation again in case affected by other inputs. The
        // last component validated will run the onValidationComplete callback
        _this3.inputs.forEach(function (component, index) {
            var validation = _this3.runValidation(component);
            if (validation.isValid && component.state._externalError) {
                validation.isValid = false;
            }
            component.setState({
                _isValid: validation.isValid,
                _isRequired: validation.isRequired,
                _validationError: validation.error,
                _externalError: !validation.isValid && component.state._externalError ? component.state._externalError : null
            }, index === _this3.inputs.length - 1 ? onValidationComplete : null);
        });

        // If there are no inputs, set state where form is ready to trigger
        // change event. New inputs might be added later
        if (!_this3.inputs.length) {
            _this3.setState({
                canChange: true
            });
        }
    };

    this.attachToForm = function (component) {
        if (_this3.inputs.indexOf(component) === -1) {
            _this3.inputs.push(component);
        }

        _this3.validate(component);
    };

    this.detachFromForm = function (component) {
        var componentPos = _this3.inputs.indexOf(component);

        if (componentPos !== -1) {
            _this3.inputs = _this3.inputs.slice(0, componentPos).concat(_this3.inputs.slice(componentPos + 1));
        }

        _this3.validateForm();
    };
}, _temp2);

if (!global.exports && !global.module && (!global.define || !global.define.amd)) {
    global.Formsy = Formsy;
}

module.exports = Formsy;